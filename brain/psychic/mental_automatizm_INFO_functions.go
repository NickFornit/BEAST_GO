/* Информационные функции, вызываемые как действия ментального автоматизма по их ID функции.

Инфо-функции - разные методы получения инфы, систематизации, поиска и т.п.
с целью найти верное действие для моторного автоматизма, а если нет,
то создания нового ментального автоматизма для продолжения итеации поиска.

Если нужно, то входные данные могут сначала помещаться в структуру входных данных типа
type inputStruct4 struct {
	par int
}
var input4 inputStruct4

Результат работы инфо-функции записывается в mentalInfoStruct
и определяется общая переменная currentInfoStructId == ID инфо-функции
*/

package psychic

/* Общая для всех информационных функций структура (типа информацонного окружения)
для сохранения найденной информации.
*/
type mentalInfo struct {
	mImgID int // ID MentalActionsImages найденного целевого действия

}
var mentalInfoStruct mentalInfo

func clinerMentalInfo(){ // НУЖНА ЛИ?..
	mentalInfoStruct.mImgID=0
	// ВСТАВЛЯТЬ ДРУГИЕ ЧЛЕНЫ ПО МЕРЕ ПОЯВЛЕНИЯ !!!!
}
/////////////////////////////////////


/* Общая переменная currentInfoStructId == ID инфо-функции),
которые могут использоваться при запуске consciousness()

Можно использовать switch currentInfoStructId{ для выявления поля структуры mentalInfoStruct
 */
var currentInfoStructId=0

///////////////////////////////////
/* Функция вызова пронумерованной функции

 */
func runMenyalFunctionID(id int){
	switch id {
	case 1: infoFunc1()//Подобрать MentalActionsImages для базового звена цепочки
	case 2: infoFunc2()//Подобрать MentalActionsImages для последующего звена цепочки
	case 3: infoFunc3()//айти подходящий мент.автоматизм по опыту ментальных Правил
	case 4: infoFunc4()//нализ инфо стркутуры и др. информации по currentInfoStructId и выдача решения
	case 5: infoFunc5()//создать и запустить ментальный автоматизм по акции
	}
}
//////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////
/* далее идут ПРОНУМЕРОВАННЫЕ ИНФОРМАЦИОННЫЕ ФУНКЦИИ,
для которых в mental_automatizm_INFO_structs.go определяются ИНФОРМАЦИОННЫЕ ГЛОБАЛЬНЫЕ СТРУКТУРЫ - для
передачи в них полученной информации.
Так же для передачи информации в инфо-функции (если это нужно, например, что найти) применяюися входне структуры.
 */
//////////////////////////////////////////////////////////




/* №0 Подобрать MentalActionsImages для базового звена цепочки
c вызовом activateInfoFunc для начальной информированности,
случайно или по заготовке редактора с Пульта
*/
func infoFunc1(){
	iID:=0// ID MentalActionsImages

	activateBaseID:=0
	activateEmotion:=0
	activateInfoFunc:=0
	activateMotorID:=0

	// TODO подобрать
	/*
	1. Поиск MentalActionsImages для следующего .NextID начинается по ментальным Правилам.
	2. Если нет правил, посмотреть, есть ли дургие ветки у данного узла и использовать их начальную инфу.
	3. Если нет дргих веток, выбрать какой-то провоцирующий.
	 */
	// поиск в Правилах
	//action:=infoFindRightMentalRukes()

	// создать
	iID,_=CreateNewlastMentalActionsImagesID(0,activateBaseID,activateEmotion,	activateInfoFunc,activateMotorID)

	mentalInfoStruct.mImgID = iID // передача инфы в структуру
	currentInfoStructId=1 // определение актуальной инфо-структуры
}
/////////////////////////////////////////////////////////


/* №2 Подобрать MentalActionsImages для последующего звена цепочки, если не найдено в опыте
с вызовом различных activateInfoFunc или
 c вызовом activateMotorID моторнорнного автоматизма (а значит, с запуском моторного с периодом ожидания),
т.е. раз нет решения, пробовать подобрать моторные действия, просмотрев цеаочку с начала.
Если в базовом звене есть другие MotorBranchID то - подсмотреть как они продолжаются с насовпажающего звена цепи!
*/
func infoFunc2(){
	iID:=0// ID MentalActionsImages

	activateBaseID:=0
	activateEmotion:=0
	activateInfoFunc:=0
	activateMotorID:=0

	// TODO подобрать
	/*
		1. Поиск MentalActionsImages для следующего .NextID начинается по ментальным Правилам.
		2. Если нет правил, посмотреть, есть ли дургие ветки у данного узла и использовать их начальную инфу.
		3. Если нет дргих веток, выбрать какой-то провоцирующий.
	*/
	// поиск в Правилах
	//action:=infoFindRightMentalRukes()


	// создать
	iID,_=CreateNewlastMentalActionsImagesID(0,activateBaseID,activateEmotion,	activateInfoFunc,activateMotorID)

	mentalInfoStruct.mImgID = iID // передача инфы в структуру
	currentInfoStructId=2 // определение актуальной инфо-структуры
}
//////////////////////////////////////////////////////////





/* №3 найти подходящий мент.автоматизм по опыту ментальных Правил
*/
func infoFunc3() {
	infoFindRightMentalRukes()
	// получили mentalInfoStruct.mImgID
	currentInfoStructId=3 // определение актуальной инфо-структуры
}
func infoFindRightMentalRukes()(int){
	mrules:=getSuitableMentalRules()
	if mrules > 0 { // по правилу найти автоматизм и запустить его
		mta := MentalTriggerAndActionArr[mrules]
		// выбираем Ответное действие из Правила
		if mta != nil {
			mentalInfoStruct.mImgID=mta.Action
			return mentalInfoStruct.mImgID
		}
	}
	mentalInfoStruct.mImgID=0
	return 0
}
//////////////////////////////////////////////////////////



/* нализ инфо стркутуры и др. информации по currentInfoStructId и выдача решения
Нужна таблица, какие инфо-функции вызывать при данной ситуации

 */
func infoFunc4(){
	if currrentFromNextID>0 {
		analisAndSintez(currrentFromNextID) // возвращает mentalInfoStruct.mImgID
	}else{
		mentalInfoStruct.mImgID=0
	}
	// получили mentalInfoStruct.mImgID
	currentInfoStructId=4 // определение актуальной инфо-структуры
}
/* анализ инфо стркутуры и др. информации по currentInfoStructId и выдача решения
Нужна таблица, какие инфо-функции вызывать при данной ситуации
Возвращает fromNextID следующего звена, даже если найден моторный автоматизм или задана объективная переактивация.
*/
func analisAndSintez(fromNextID int)(int){
	clinerMentalInfo()
	// сначала стандартно:
	/*
		1. Поиск MentalActionsImages для следующего .NextID начинается по ментальным Правилам.
		2. Если нет правил, посмотреть, есть ли дургие ветки у данного узла и использовать их начальную инфу.
		3. Если нет дргих веток, выбрать какой-то провоцирующий.
	*/
	// поиск в Правилах
	//action:=infoFindRightMentalRukes()

	// сложные типы данных, полученные в инфо-функциях
	switch currentInfoStructId{

	}




	return mentalInfoStruct.mImgID // очищенный или заполненный
}
//////////////////////////////////////////////////////////


/* №5 создать и запустить ментальный автоматизм по акции -
ВСЕГДА ПОСЛЕ ПОЛУЧЕНИЯ ОБРАЗА ДЕЙСТВИЯ mentalInfoStruct.mImgID
 */
func infoFunc5() {
	if mentalInfoStruct.mImgID >0 {
		infoCreateAndRunMentAtmzmFromAction(mentalInfoStruct.mImgID)
	}
	// получили mentalInfoStruct.mImgID
	currentInfoStructId=5 // определение актуальной инфо-структуры
}
func infoCreateAndRunMentAtmzmFromAction(actImgID int){
	if mentalInfoStruct.mImgID ==0 {
		return
	}
	id, matmzm := createMentalAutomatizmID(0, actImgID, 1)
	if id >0 {
		// запустить мент.автоматизм
		RunMentalMentalAutomatizm(matmzm)
	}
}
//////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////

/*
*************** Группировка зеркальных автоматизмов *********************
Были зафиксированы две цепочки диалога по 2 шага каждая (1 шаг - 1 пара вопрос + ответ):
а) Привет – привет, как дела – нормально
б) Приветствую – привет, Ты как – отлично
Из них сформировались 2 зеркальных автоматизма: привет - как дела, привет - ты как. Их можно сгруппировать и вывести в отдельном
массиве варианты ответов на один пускатель: привет - как дела, ты как.
При поиске ответа нужно искать в этом массиве и выбирать варианты например по счетчику успешности. Это будет намного быстрее,
чем перебирать весь массив автоматизмов.
Для такой группировки нужно при создании нового зеркального автоматизма дописывать
в этот массив новый вариант в нужной строке: находить в массиве пусковое слово и добавлять к нему вариант ответа.
По сути это групповой запрос, только выделенный в динамическую таблицу. Так БД-шники часто делают, если приходится ворочать объемные
данные под миллионы записей. Вместо тяжелых тормозных запросов строятся буферные таблицы и забиваются через хранимки при совершении
операций с данными.
*/