/* Базовая система самоощущения (актуализация доступной информации),
функция поддержвания информационной среды в зависимости от текущй ситуации -
обдщая картина понимания ситуации,
с функцией лени - думать или не думать: мотивированность думать зависит от ситуации, ее опасности. 
Решение что-делать или просто игнорировать ситуацию - важнейший параметр индивидуальной адаптивности. 
Не просто искать способ выйти из опасного состояния, а искать как улучшить состояние, 
каким бы оно ни было вплоть до полной неудовлетворенности существующим, когда поис ведется в любой ситуации.
Нужна функция, определяющая лень с индивидуализированными параметрами 
(м.б. зависящими от более базовых индивид.параментров).
Функция поддерживается системой самоощущения, 
которая работает независимо от активации дерева понимания по каждому пульсу. 

Активация func consciousness - после включения или пробуждения - начало цепочки мыслей,
а так же - по активности дерева (ор.рефлекс) - срабатывает функция делать-неделать.

Кроме гомеостатического инфо.окрыжения psi_information_environment.go
есть psi_information_environment_mental.go куда помещаются результаты информационных функций.
Использует субъективную часть эпизодов памяти - субъективный тип (для записи эпизодов цепочки мыслей).

Функция consciousness() проходит через 4 уровня решений - выделенных комментариями.
Если решение не найдено на данном уровне, то отрабатывает следующий уровень сложности обработки (что характеризует эволюционную последовательность их появления).

РАБОТА consciousness() кадого уровня описана по месту.

*/


package psychic

//////////////////////////////
var allowConsciousnessProcess=false // при включении и просыпании - 1 раз


var saveEvolushnStage=0 // сохранение значения уровня осмысления == стадии развития при произвольном изменении уровня


////////////////////////////////////////////////////////////
/* Главная, постоянно активная с каждым пульсом функция поддержвания информационной среды и произвольности.
Изолированная от непосредственных воздействий и поэтому самостоятельная система оценки и корректировки состояния,
происходит с формированием опыта прозвольности выполнения Правил и их выбора для данных условий (psy_Experience.go),
в частности, Правил относительно самого себя (самосознание).

Начинает работать с if EvolushnStage > 3

По каждому пульсу система осознания активируется по ор.рефлексу
(из ор.рефлекса - вызов функции активации самосознания и по результатам - продолжить), 
а если в этот такт нет ор.рефлекса - то из PsychicCountPuls(.
Вид активации - при вызове функции осознания.
activationType == 0 - не бывает
activationType == 1 - активация ориентировочным рефлексом новой ситуации
activationType == 2 - активация "внутренним" (произвольным) ориентировочным рефлексом

В принципе здесь должны исправляться все лажи ответов предыдущих периодов...
*/
func consciousness(activationType int,fromLev int)(bool){

	if !allowConsciousnessProcess{
		return false
	}

	// вернуть стадию развития
	if saveEvolushnStage >0 {// иначе оно обнуляет EvolushnStage
		EvolushnStage = saveEvolushnStage // возвращаем уровень осмысления
	}

/* Период ожидания ответа LastRunAutomatizmPulsCount при поочередном Стимуле-Ответе есть всегда.
А здсь - поиск Ответа именно после каждого Стимула. Так что LastRunAutomatizmPulsCount в функции не учитываем.
 */

// ПЕРВЫЙ УРОВЕНЬ, самый примитивный уровень:
	// есть ли штатный мот.автоматизм и нужно ли его менять или задумываться
	if fromLev==0 || fromLev==1 {
		nArr := GetMotorsAutomatizmListFromTreeId(detectedActiveLastNodID)
		/* - только привязанные к ветке, а не мягкий алгоритм
		      currentAutomatizmAfterTreeActivatedID = getAutomatizmFromNodeID(detectedActiveLastNodID)
		   Если нет привязанных - находим решение - по сдедующим уровням привлечения осознания.
		*/
		if nArr != nil {
			for i := 0; i < len(nArr); i++ {
				if nArr[i].Belief == 2 && nArr[i].Usefulness > 0 { // есть нормальный, пусть выполняется
					//currentAutomatizmAfterTreeActivatedID=nArr[i].ID
					return false
				}
			}
		}
	}
	// нет штатного автоматизма
	/////////////////////////////////////////////////////////

	refreshCurrentInformationEnvironment()// нужен для func getSuitableRules
// if CurrentInformationEnvironment.veryActualSituation || CurrentInformationEnvironment.danger{

// ВТОРОЙ УРОВЕНЬ - попытка использования примитивных Правил
	if fromLev==0 || fromLev==2 {
		rules := getSuitableRules(activationType)
		if rules > 0 { // по правилу найти автоматизм и запустить его
			ta := TriggerAndActionArr[rules]
			purpose := getPurposeGenetic()
			ai := ActionsImageArr[ta.Trigger]
			if ai != nil {
				purpose.actionID = ai
				atmzm := createAndRunAutomatizmFromPurpose(purpose)
				if atmzm != nil {
					return true // заблокирвать более низкоуровневое
				}
			}
		}
	}
	/////////////////////////////////////////////////////////

	//if EvolushnStage > 3 { - уже обеспечено
/* ТРЕТИЙ УРОВЕНЬ - попытка найти решение, используя всю текущую инфрмацию с учетом срочности.
   Ментальные автоматизмы нужны только если нет мот.автоматизма или его нужно переделать.
Т.е. привязанный к ветке дерева понимания мент автоматизм должен срабатывать ЗДЕСЬ.
Он продолжается по NextID или даже ветвится в зависимости от ситуации.
А если его еще нет, то создать БАЗОВЫЙ: м.б. сделать редактор базовых в зависимости от Mood, EmotionID и SituationID
Работа третьего уровня.
   Запуск ментального автоматизма сопровождается обязательным перезапуском consciousness()
   К ветке UnderstandingNode всегда пристегнут Базовый ментальный автоматизм, с которого начинается просмотр в функции consciousness() на ее Третьем уровне. От него может идти цепочка дочерних (у них brangeID=0).
   Каждый запускаемый мент. автоматизм (кроме MentalActionsImages.activateMotorID) после отработки вызывает consciousness() прямо или косвенно. В течение одного пульса может быть множество перезапусков consciousness() с продолжением процесса мышления и добавления в цепь (.NextID) новых автоматизмов.
   Базовый автоматизм должен прикинуть, какой будет следующий – путем выбора MentalActionsImages, сделать его, запустить, а в следующем цикле consciousness() использовать инфу (и все окружение) для формирования моторного автоматизма (MentalActionsImages.activateMotorID)  и тогда запустить его с периодом ожидания.
   По результату записывается Правило. Если хорошо, то данная цепочка так и заканчивается запуском моторного автоматизма (MentalActionsImages.activateMotorID), если плохо – формируется следующая цепочка (.NextID) с выбором другого MentalActionsImages и т.д. Т.е. формирование следующего звена цепочки идет С УЧЕТОМ ОПЫТА (MentalActionsImages) ПРЕДЫДУЩИХ.
   Из-за того, что у дочерних автоматизмов brangeID=0, они подвисают в общий набор решений и могут участвовать в разных цепочках.
   Поиск MentalActionsImages для следующего .NextID идет по ментальным Правилам или по функции случайного или прописанного в редакторе подбора с учетом опыта предыдущих (Переактивации Базового состояния лии эмоций выбираются на 5-й ступени развития).

   Структура мент Правила MentalTriggerAndAction начинается или с мент.действия MentalActionsImage или с моторного ActionsImage, потом - Ответ MentalActionsImage и обычный Эффект.

   После срабатывания инфо-функции (.activateInfoFunc) информация добавляется к текущему информационному окружения в виде одной из соответствующих глобальных структур (для каждой инфо-функции в mental_automatizm_INFO_structs.go создается ее дежурная структура и задается значение общей переменной currentInfoStructId == ID инфо-функции), которые могут использоваться при запуске consciousness().
 */
	if fromLev==0 || fromLev==3 {
		// детекция ленивого состояния
		if isIdleness() {
			// пофиг все, можно лениво обрабатывать накопившиеся структуры, реагирование - на уровне - до EvolushnStage < 4
			saveEvolushnStage = EvolushnStage
			EvolushnStage = 3 // нагло и просто :) - произвольный откат уровня осознания

			processingFreeState() // обработка структур в свободном состоянии может быть долгой -

			EvolushnStage = saveEvolushnStage // возвращаем уровень осмысления, иначе зависнет на этой стадии
			return false                      // пусть выполняется все менее высокоуровневое
		}
		// нужен поиск решений
		/* Есть ли ментальный автоматизм для ветки UnderstandingNode? Если нет, то сформировать базовый.
		   Если есть с .activateMotorID>0 - запустить моторный автоматизм activateMotorID,
		   если нет .activateMotorID==0 - создать следующий цепоцечный мент.автоматизм и прописать его ID в .NextID
		*/
		mentA := MentalAutomatizmsFromBranchID[detectedActiveLastUnderstandingNodID]
		if mentA == nil {
			// подбираем подходящий MentalActionsImages и создаем базовый автоматизм
			infoFunc0()
			createMentalAutomatizmID(0, detectedActiveLastUnderstandingNodID, info0.mImgID, 1)
			consciousness(activationType,3)
			return true // ничего не делать при перезапуске
		}

		/*
			mrules:=getSuitableMentalRules(activationType)
			if mrules > 0 {// по правилу найти автоматизм и запустить его
				mta:=MentalTriggerAndActionArr[mrules]
				mai:=MentalActionsImagesArr[mta.Trigger]
					_,matmzm := createAndRunMentalAutomatizm(mai.ID)
					if matmzm != nil {
						return true // заблокирвать более низкоуровневое? нужно ли блокировать объективные действия при мышлении?
					}
			}
		*/
	}

	/////////////////////////////////////////////////////////

	if fromLev==0 || fromLev==4 {
		if EvolushnStage > 4 {
			// ЧЕТВЕРТЫЙ УРОВЕНЬ - доминанта нерешенной проблемы - только если нет срочности
			// и тут - Стек отложенных дел.
			if CurrentInformationEnvironment.veryActualSituation || CurrentInformationEnvironment.danger {
				// TODO
			} else { // нет решения, паника, откатиться на прежний уровень регирования
				// TODO аварийное решение проблемы
				return false // пусть выполняется все менее высокоуровневое
			}

		} //if EvolushnStage > 4
	}
		/////////////////////////////////////////////////////////







	/////////////////////////////////////////////////////////



return false // не блокировать последующий код ориентировочного рефлекса.
}
////////////////////////////////////////////


///////////////////////////////
// обновление состояния информационной среды
func refreshCurrentInformationEnvironment(){
	///////// Информационная среда осознания ситуации
	// Нужно собрать всю информацию, которая может повлиять на решение.
	//  получение текущего состояния информационной среды: отражение Базового состояния и Активных Базовых контекстов
	GetCurrentInformationEnvironment()

	// оценка опасности ситуации, необходиомсть срочных действий
	veryActualSituation=CurrentInformationEnvironment.veryActualSituation
	// выявить ID парамктров гомеостаза как цели для улучшения в данных условиях
	curTargetArrID=CurrentInformationEnvironment.curTargetArrID

	/* Еще информация:
	жизненный опыт  psy_Experience.go
	доминанта psy_problem_dominanta.go
	субъектиная оценка ситуации для применения произвольности
	*/

	// актуальной инфой являются узлы активной ветки дерева понимания, особенно контекст SituationID
}
///////////////////////////////////////////////


// детекция ленивого состояния
func isIdleness()(bool){
	if veryActualSituation {
		return false
	}

	if isCurrentProblemDominanta != nil{
		return false
	}

	return true
}
///////////////////////////////////////////////////////
// обработка структур в свободном состоянии, в первую очередь - эпизодической памяти
func processingFreeState(){
	// TODO переработка происходившего, в первую очередь - эпизодической памяти
	//EpisodeMemoryLastCalcID - последний эпизод, который был осмыслен в лени или во сне
}
//////////////////////////////////////////////////////
